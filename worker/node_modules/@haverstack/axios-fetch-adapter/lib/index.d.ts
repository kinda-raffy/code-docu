declare module '@haverstack/axios-fetch-adapter/axios/core/AxiosError' {
  export default AxiosError;
  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  function AxiosError(message: string, code?: string | undefined, config?: Object | undefined, request?: Object | undefined, response?: Object | undefined): Error;
  class AxiosError {
      /**
       * Create an Error with the specified message, config, error code, request and response.
       *
       * @param {string} message The error message.
       * @param {string} [code] The error code (for example, 'ECONNABORTED').
       * @param {Object} [config] The config.
       * @param {Object} [request] The request.
       * @param {Object} [response] The response.
       *
       * @returns {Error} The created error.
       */
      constructor(message: string, code?: string | undefined, config?: Object | undefined, request?: Object | undefined, response?: Object | undefined);
      stack: string | undefined;
      message: string;
      name: string;
      code: string | undefined;
      config: Object | undefined;
      request: Object | undefined;
      response: Object | undefined;
  }
  namespace AxiosError {
      function from(error: any, code: any, config: any, request: any, response: any, customProps: any): any;
  }

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/AxiosURLSearchParams' {
  export default AxiosURLSearchParams;
  /**
   * It takes a params object and converts it to a FormData object
   *
   * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
   * @param {Object<string, any>} options - The options object passed to the Axios constructor.
   *
   * @returns {void}
   */
  function AxiosURLSearchParams(params: {
      [x: string]: any;
  }, options: {
      [x: string]: any;
  }): void;
  class AxiosURLSearchParams {
      /**
       * It takes a params object and converts it to a FormData object
       *
       * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
       * @param {Object<string, any>} options - The options object passed to the Axios constructor.
       *
       * @returns {void}
       */
      constructor(params: {
          [x: string]: any;
      }, options: {
          [x: string]: any;
      });
      _pairs: any[];
  }

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/bind' {
  export default function bind(fn: any, thisArg: any): (...args: any[]) => any;

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/buildURL' {
  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @param {?object} options
   *
   * @returns {string} The formatted url
   */
  export default function buildURL(url: string, params?: object | undefined, options: object | null): string;

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/combineURLs' {
  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   *
   * @returns {string} The combined URL
   */
  export default function combineURLs(baseURL: string, relativeURL: string): string;

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/isAbsoluteURL' {
  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   *
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  export default function isAbsoluteURL(url: string): boolean;

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/helpers/toFormData' {
  export default toFormData;
  /**
   * Convert a data object to FormData
   *
   * @param {Object} obj
   * @param {?Object} [formData]
   * @param {?Object} [options]
   * @param {Function} [options.visitor]
   * @param {Boolean} [options.metaTokens = true]
   * @param {Boolean} [options.dots = false]
   * @param {?Boolean} [options.indexes = false]
   *
   * @returns {Object}
   **/
  /**
   * It converts an object into a FormData object
   *
   * @param {Object<any, any>} obj - The object to convert to form data.
   * @param {string} formData - The FormData object to append to.
   * @param {Object<string, any>} options
   *
   * @returns
   */
  function toFormData(obj: any, formData: string, options: {
      [x: string]: any;
  }): string;

}
declare module '@haverstack/axios-fetch-adapter/axios/lib/utils' {
  namespace _default {
      export { isArray };
      export { isArrayBuffer };
      export { isBuffer };
      export { isFormData };
      export { isArrayBufferView };
      export { isString };
      export { isNumber };
      export { isBoolean };
      export { isObject };
      export { isPlainObject };
      export { isUndefined };
      export { isDate };
      export { isFile };
      export { isBlob };
      export { isRegExp };
      export { isFunction };
      export { isStream };
      export { isURLSearchParams };
      export { isTypedArray };
      export { isFileList };
      export { forEach };
      export { merge };
      export { extend };
      export { trim };
      export { stripBOM };
      export { inherits };
      export { toFlatObject };
      export { kindOf };
      export { kindOfTest };
      export { endsWith };
      export { toArray };
      export { forEachEntry };
      export { matchAll };
      export { isHTMLForm };
      export { hasOwnProperty };
      export { hasOwnProperty as hasOwnProp };
      export { reduceDescriptors };
      export { freezeMethods };
      export { toObjectSet };
      export { toCamelCase };
      export { noop };
      export { toFiniteNumber };
      export { findKey };
      export { _global as global };
      export { isContextDefined };
      export { toJSONObject };
  }
  export default _default;
  const isArray: (arg: any) => arg is any[];
  function isArrayBuffer(thing: any): boolean;
  /**
   * Determine if a value is a Buffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer(val: any): boolean;
  /**
   * Determine if a value is a FormData
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(thing: any): boolean;
  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val: any): boolean;
  function isString(thing: any): boolean;
  function isNumber(thing: any): boolean;
  /**
   * Determine if a value is a Boolean
   *
   * @param {*} thing The value to test
   * @returns {boolean} True if value is a Boolean, otherwise false
   */
  function isBoolean(thing: any): boolean;
  /**
   * Determine if a value is an Object
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject(thing: any): boolean;
  /**
   * Determine if a value is a plain Object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a plain Object, otherwise false
   */
  function isPlainObject(val: any): boolean;
  function isUndefined(thing: any): boolean;
  function isDate(thing: any): boolean;
  function isFile(thing: any): boolean;
  function isBlob(thing: any): boolean;
  function isRegExp(thing: any): boolean;
  function isFunction(thing: any): boolean;
  /**
   * Determine if a value is a Stream
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val: any): boolean;
  function isURLSearchParams(thing: any): boolean;
  function isTypedArray(thing: any): any;
  function isFileList(thing: any): boolean;
  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   *
   * @param {Boolean} [allOwnKeys = false]
   * @returns {any}
   */
  function forEach(obj: Object | any[], fn: Function, { allOwnKeys }?: boolean | undefined): any;
  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   *
   * @returns {Object} Result of all merge properties
   */
  function merge(...args: any[]): Object;
  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   *
   * @param {Boolean} [allOwnKeys]
   * @returns {Object} The resulting value of object a
   */
  function extend(a: Object, b: Object, thisArg: Object, { allOwnKeys }?: boolean | undefined): Object;
  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   *
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str: string): string;
  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   *
   * @returns {string} content value without BOM
   */
  function stripBOM(content: string): string;
  /**
   * Inherit the prototype methods from one constructor into another
   * @param {function} constructor
   * @param {function} superConstructor
   * @param {object} [props]
   * @param {object} [descriptors]
   *
   * @returns {void}
   */
  function inherits(constructor: Function, superConstructor: Function, props?: object | undefined, descriptors?: object | undefined): void;
  /**
   * Resolve object with deep prototype chain to a flat object
   * @param {Object} sourceObj source object
   * @param {Object} [destObj]
   * @param {Function|Boolean} [filter]
   * @param {Function} [propFilter]
   *
   * @returns {Object}
   */
  function toFlatObject(sourceObj: Object, destObj?: Object | undefined, filter?: boolean | Function | undefined, propFilter?: Function | undefined): Object;
  function kindOf(thing: any): any;
  function kindOfTest(type: any): (thing: any) => boolean;
  /**
   * Determines whether a string ends with the characters of a specified string
   *
   * @param {String} str
   * @param {String} searchString
   * @param {Number} [position= 0]
   *
   * @returns {boolean}
   */
  function endsWith(str: string, searchString: string, position?: number | undefined): boolean;
  /**
   * Returns new array from array like object or null if failed
   *
   * @param {*} [thing]
   *
   * @returns {?Array}
   */
  function toArray(thing?: any): any[] | null;
  /**
   * For each entry in the object, call the function with the key and value.
   *
   * @param {Object<any, any>} obj - The object to iterate over.
   * @param {Function} fn - The function to call for each entry.
   *
   * @returns {void}
   */
  function forEachEntry(obj: any, fn: Function): void;
  /**
   * It takes a regular expression and a string, and returns an array of all the matches
   *
   * @param {string} regExp - The regular expression to match against.
   * @param {string} str - The string to search.
   *
   * @returns {Array<boolean>}
   */
  function matchAll(regExp: string, str: string): Array<boolean>;
  function isHTMLForm(thing: any): boolean;
  function hasOwnProperty(obj: any, prop: any): boolean;
  function reduceDescriptors(obj: any, reducer: any): void;
  /**
   * Makes all methods read-only
   * @param {Object} obj
   */
  function freezeMethods(obj: Object): void;
  function toObjectSet(arrayOrString: any, delimiter: any): {};
  function toCamelCase(str: any): any;
  function noop(): void;
  function toFiniteNumber(value: any, defaultValue: any): any;
  function findKey(obj: any, key: any): string | null;
  const _global: any;
  function isContextDefined(context: any): boolean;
  function toJSONObject(obj: any): any;

}
declare module '@haverstack/axios-fetch-adapter/buildFullPath' {
  export function buildFullPath(requestedURL: string, baseURL?: string): string;

}
declare module '@haverstack/axios-fetch-adapter/buildFullPath.test' {
  export {};

}
declare module '@haverstack/axios-fetch-adapter/index' {
  import type { AxiosPromise, AxiosRequestConfig } from "@haverstack/axios-fetch-adapter/axios/index";
  export default function fetchAdapter(config: AxiosRequestConfig): AxiosPromise;

}
declare module '@haverstack/axios-fetch-adapter/index.test' {
  export {};

}
declare module '@haverstack/axios-fetch-adapter' {
  import main = require('@haverstack/axios-fetch-adapter/src/index');
  export = main;
}